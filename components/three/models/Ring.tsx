/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useMemo, useRef } from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { MeshPhysicalMaterial } from "three";
import { useFrame } from "@react-three/fiber";
import Math2 from "../../../utils/Math2";
import Settings from "../../../utils/Settings";

type GLTFResult = GLTF & {
  nodes: {
    RingBase: THREE.Mesh;
    RingDisplay: THREE.Mesh;
  };
  materials: {
    Base: THREE.MeshStandardMaterial;
    LCD: THREE.MeshStandardMaterial;
  };
};

type TimelineIn = {
  progress: number;
  et: number;
};

type TimelineFunction = (
  i: TimelineIn
) => [[number, number, number], [number, number, number], number, () => void];

export default function Ring({ ...props }: JSX.IntrinsicElements["group"]) {
  const group = useRef<THREE.Group>(null);
  const ref = useRef<THREE.Group>(null);
  const lcd = useRef<THREE.Mesh>(null);
  const prevS = useRef<number>(-1);
  const local = useRef<THREE.Group>(null);
  const { nodes } = useGLTF("/models/Ring.gltf") as GLTFResult;
  const [call, alert, blank, pay1, pay2, buy] = useTexture([
    "/screens/1Call.png",
    "/screens/4Alert.png",
    "/screens/0Blank.png",
    "/screens/2Pay.png",
    "/screens/3Pay.png",
    "/screens/5Buy.png",
  ]);
  const BaseMaterial = useMemo(() => {
    return new MeshPhysicalMaterial({
      color: "#000000",
      roughness: 0,
      metalness: 1,
      clearcoat: 0.8,
      clearcoatRoughness: 0,
      reflectivity: 0.5,
    });
  }, []);
  const LCD = useMemo(() => {
    return new MeshPhysicalMaterial({
      map: call,
      roughness: 0,
      metalness: 0,
      color: "#ffcece",
      emissiveMap: alert,
    });
  }, []);
  useFrame(({ clock, mouse, viewport }) => {
    const scroll = scrollY / (document.body.scrollHeight - window.innerHeight);

    if (!local.current) return null;
    if (!ref.current) return null;
    if (!lcd.current) return null;

    //TODO Play with precision
    const sections = Settings.Sections;
    const et = clock.getElapsedTime();
    const section = Math2.Clamp(Math.floor(scroll * sections), 0, sections - 1);
    const progress = Math2.Clamp(scroll * sections - section, 0, sections - 1);

    const ChangeTexture = (t: THREE.Texture) => {
      if (!lcd.current) return null;
      if (!lcd.current.material) return null;
      (lcd.current.material as THREE.MeshPhysicalMaterial).map = t;
    };

    const timeline: TimelineFunction[] = [
      () => {
        //? LANDING PAGE
        const [x, y, z] = [
          0,
          Math2.Lerp(-0.5, 0, progress) + Math.sin(et * 0.5) * 0.1,
          progress * 1,
        ];
        const [rx, ry, rz] = [
          Math2.Lerp(-Math.PI / 2, 0.2, progress),
          Math2.Lerp(0, 0.2, progress),
          Math2.Lerp(0, 0.3 + Math.PI * 2, progress),
        ];
        const rl = 0;
        return [
          [x, y, z],
          [rx, ry, rz],
          rl,
          () => {
            ChangeTexture(blank);
          },
        ];
      },
      //? ALERT
      () => {
        const [x, y, z] = [0, Math.sin(et * 0.5) * 0.1, 1];
        const [rx, ry, rz] = [0.2, 0.2 + progress * 0.2, 0.3 + Math.PI * 2];
        const rl = 0;
        return [
          [x, y, z],
          [rx, ry, rz],
          rl,
          () => {
            ChangeTexture(alert);
          },
        ];
      },
      //? VIBRATIONS
      () => {
        const n = Math.sin(et * 30) * 0.01;
        const [x, y, z] = [0, n, 1.5];
        const [rx, ry, rz] = [
          0.2 + progress * 0.2 + Math.sin(et * 20) * 0.1,
          0.2,
          -0.3 + Math.PI * 2,
        ];
        const rl = 0;
        return [
          [x, y, z],
          [rx, ry, rz],
          rl,
          () => {
            ChangeTexture(call);
          },
        ];
      },
      //? GESTURES
      () => {
        const [x, y, z] = [
          (mouse.x * viewport.width) / 2,
          (mouse.y * viewport.height) / 2,
          0,
        ];
        const [rx, ry, rz] = [-Math.PI / 2, 0, Math.PI * 2];
        const rl = 0;
        return [[x, y, z], [rx, ry, rz], rl, () => {}];
      },
      //? NFC
      () => {
        const [x, y, z] = [
          0,
          Math.sin(et * 0.5) * 0.05 + 0.1 - progress / 2,
          1,
        ];
        const [rx, ry, rz] = [0.2, 0.2 + progress * 0.2, 0.3 + Math.PI * 2];
        const rl = 0;
        if (!lcd.current || !lcd.current.material) {
          return [
            [x, y, z],
            [rx, ry, rz],
            rl,
            () => {
              ChangeTexture(pay1);
            },
          ];
        }
        if (
          progress > 0.6 &&
          (lcd.current?.material as THREE.MeshPhysicalMaterial).map !== pay2
        ) {
          ChangeTexture(pay2);
        }
        return [
          [x, y, z],
          [rx, ry, rz],
          rl,
          () => {
            ChangeTexture(pay1);
          },
        ];
      },
      //? BUY
      () => {
        const n = Math.sin(et * 0.5);
        const [x, y, z] = [0, n * 0.1, 1 + progress];
        const [rx, ry, rz] = [
          0.2 + progress * Math.PI * 2,
          (n + 0.5) * 0.2 + progress * 0.2,
          0.3 + Math.PI * 2,
        ];
        const rl = 0;
        return [
          [x, y, z],
          [rx, ry, rz],
          rl,
          () => {
            ChangeTexture(buy);
          },
        ];
      },
    ];
    let [position, rotation, rotationLocal, StartTrigger] = timeline[section]({
      progress,
      et,
    });

    if (prevS.current !== section) {
      StartTrigger();
    }
    const transitionSpeed = 0.1;
    //Animate using Math2.Lerp(a, b, t)
    const currentPos = [
      ref.current.position.x,
      ref.current.position.y,
      ref.current.position.z,
    ];
    const currentRot = [
      ref.current.rotation.x,
      ref.current.rotation.y,
      ref.current.rotation.z,
    ];
    // ref.current.position.set();

    ref.current.position.set(
      Math2.Lerp(currentPos[0], position[0], transitionSpeed),
      Math2.Lerp(currentPos[1], position[1], transitionSpeed),
      Math2.Lerp(currentPos[2], position[2], transitionSpeed)
    );
    ref.current.rotation.set(
      Math2.Lerp(currentRot[0], rotation[0], transitionSpeed),
      Math2.Lerp(currentRot[1], rotation[1], transitionSpeed),
      Math2.Lerp(currentRot[2], rotation[2], transitionSpeed)
    );

    const currentLocalRot = local.current.rotation.y;
    local.current.rotation.set(
      0,
      Math2.Lerp(currentLocalRot, rotationLocal, transitionSpeed),
      0
    );
    prevS.current = section;
  });
  return (
    <group ref={group} {...props} dispose={null}>
      {/*//? To rotate and position the whole ring */}
      {/* <group position={[0, -1, -10]} rotation={[-0.1, 0.7, 0.3]}> */}
      <group ref={ref} rotation={[-Math.PI / 2, 0, 0]}>
        {/*//? To scale and rotate local rotation of Z */}
        <group ref={local} rotation={[0, 0, 0]} scale={-0.5}>
          {/*//? Base */}
          <mesh
            geometry={nodes.RingBase.geometry}
            material={BaseMaterial}
            scale={1.08}
          />
          {/*//? Display */}
          <mesh
            geometry={nodes.RingDisplay.geometry}
            material={LCD}
            scale={1.08}
            ref={lcd}
          />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/models/Ring.gltf");
