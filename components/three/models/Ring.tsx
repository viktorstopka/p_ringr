/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useMemo, useRef } from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { MeshPhysicalMaterial } from "three";
import { useFrame } from "@react-three/fiber";
import Math2 from "../../../utils/Math2";

type GLTFResult = GLTF & {
  nodes: {
    RingBase: THREE.Mesh;
    RingDisplay: THREE.Mesh;
  };
  materials: {
    Base: THREE.MeshStandardMaterial;
    LCD: THREE.MeshStandardMaterial;
  };
};

type TimelineIn = {
  progress: number;
  et: number;
};

type TimelineFunction = (
  i: TimelineIn
) => [[number, number, number], [number, number, number], number];

export default function Ring({ ...props }: JSX.IntrinsicElements["group"]) {
  const group = useRef<THREE.Group>(null);
  const ref = useRef<THREE.Group>(null);
  const local = useRef<THREE.Group>(null);
  const { nodes, materials } = useGLTF("/models/Ring.gltf") as GLTFResult;
  const [call] = useTexture(["/screens/4Alert.png"]);
  const BaseMaterial = useMemo(() => {
    return new MeshPhysicalMaterial({
      color: "#000000",
      roughness: 0,
      metalness: 1,
      clearcoat: 0.8,
      clearcoatRoughness: 0,
      reflectivity: 0.5,
    });
  }, []);
  const LCD = useMemo(() => {
    return new MeshPhysicalMaterial({
      map: call,
      roughness: 0,
      metalness: 0,
      color: "#ffcece",
      emissiveMap: call,
    });
  }, []);
  useFrame(({ clock }) => {
    const scroll = scrollY / (document.body.scrollHeight - window.innerHeight);
    if (!local.current) {
      return null;
    }
    if (!ref.current) return null;
    //TODO Play with precision
    const sections = 2;
    const et = clock.getElapsedTime();
    const section = Math2.Clamp(Math.floor(scroll * sections), 0, 1);
    const progress = Math2.Clamp(scroll * sections - section, 0, 1);

    const timeline: TimelineFunction[] = [
      () => {
        //? LANDING PAGE
        const [x, y, z] = [
          0,
          Math2.Lerp(-0.5, 0, progress) + Math.sin(et * 0.5) * 0.1,
          progress * 1,
        ];
        const [rx, ry, rz] = [
          Math2.Lerp(-Math.PI / 2, 0.2, progress),
          Math2.Lerp(0, 0.2, progress),
          Math2.Lerp(0, 0.3 + Math.PI * 2, progress),
        ];
        const rl = 0;
        return [[x, y, z], [rx, ry, rz], rl];
      },
      //? ALERT
      () => {
        const [x, y, z] = [0, Math.sin(et * 0.5) * 0.1, 1];
        const [rx, ry, rz] = [0.2, 0.2, 0.3 + Math.PI * 2];
        const rl = 0;
        return [[x, y, z], [rx, ry, rz], rl];
      },
      //? VIBRATIONS
      //? GESTURES
      //? NFC
    ];
    let [position, rotation, rotationLocal] = timeline[section]({
      progress,
      et,
    });
    const transitionSpeed = 0.1;
    //Animate using Math2.Lerp(a, b, t)
    const currentPos = [
      ref.current.position.x,
      ref.current.position.y,
      ref.current.position.z,
    ];
    const currentRot = [
      ref.current.rotation.x,
      ref.current.rotation.y,
      ref.current.rotation.z,
    ];
    // ref.current.position.set();
    console.log(currentPos);
    console.log();

    ref.current.position.set(
      Math2.Lerp(currentPos[0], position[0], transitionSpeed),
      Math2.Lerp(currentPos[1], position[1], transitionSpeed),
      Math2.Lerp(currentPos[2], position[2], transitionSpeed)
    );
    ref.current.rotation.set(
      Math2.Lerp(currentRot[0], rotation[0], transitionSpeed),
      Math2.Lerp(currentRot[1], rotation[1], transitionSpeed),
      Math2.Lerp(currentRot[2], rotation[2], transitionSpeed)
    );

    const currentLocalRot = local.current.rotation.y;
    local.current.rotation.set(
      0,
      Math2.Lerp(currentLocalRot, rotationLocal, transitionSpeed),
      0
    );
  });
  return (
    <group ref={group} {...props} dispose={null}>
      {/*//? To rotate and position the whole ring */}
      {/* <group position={[0, -1, -10]} rotation={[-0.1, 0.7, 0.3]}> */}
      <group ref={ref} rotation={[-Math.PI / 2, 0, 0]}>
        {/*//? To scale and rotate local rotation of Z */}
        <group ref={local} rotation={[0, 0, 0]} scale={-0.5}>
          {/*//? Base */}
          <mesh
            geometry={nodes.RingBase.geometry}
            material={BaseMaterial}
            scale={1.08}
          />
          {/*//? Display */}
          <mesh
            geometry={nodes.RingDisplay.geometry}
            material={LCD}
            scale={1.08}
          />
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/models/Ring.gltf");
